// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                  = require("bs-platform/lib/js/list.js");
var $$Array               = require("bs-platform/lib/js/array.js");
var Block                 = require("bs-platform/lib/js/block.js");
var Curry                 = require("bs-platform/lib/js/curry.js");
var $$String              = require("bs-platform/lib/js/string.js");
var Hashtbl               = require("bs-platform/lib/js/hashtbl.js");
var Js_dict               = require("bs-platform/lib/js/js_dict.js");
var Js_json               = require("bs-platform/lib/js/js_json.js");
var Caml_obj              = require("bs-platform/lib/js/caml_obj.js");
var Pervasives            = require("bs-platform/lib/js/pervasives.js");
var GraphQL$ReactTemplate = require("./GraphQL.bs.js");

function nullable(y) {
  if (typeof y === "number" || y.tag !== 2) {
    return y;
  } else {
    return y[0];
  }
}

function joinWith(sep, strs) {
  if (strs) {
    return List.fold_left((function (a, b) {
                  return a + (sep + b);
                }), strs[0], strs[1]);
  } else {
    return "";
  }
}

function unifyObjectFields(keyValuePairsA, keyValuePairsB) {
  var aux = function (pairsA, pairsB) {
    var exit = 0;
    var rest;
    if (pairsA) {
      if (pairsB) {
        var ys = pairsB[1];
        var match = pairsB[0];
        var typeB = match[1];
        var keyB = match[0];
        var xs = pairsA[1];
        var match$1 = pairsA[0];
        var typeA = match$1[1];
        var keyA = match$1[0];
        if (Caml_obj.caml_lessthan(keyA, keyB)) {
          return /* :: */[
                  /* tuple */[
                    keyA,
                    nullable(typeA)
                  ],
                  aux(xs, pairsB)
                ];
        } else if (Caml_obj.caml_greaterthan(keyA, keyB)) {
          return /* :: */[
                  /* tuple */[
                    keyB,
                    nullable(typeB)
                  ],
                  aux(pairsA, ys)
                ];
        } else if (Caml_obj.caml_equal(keyA, keyB)) {
          return /* :: */[
                  /* tuple */[
                    keyA,
                    unify(typeA, typeB)
                  ],
                  aux(xs, ys)
                ];
        } else {
          return Pervasives.failwith("Should match one of the above!");
        }
      } else {
        rest = pairsA;
        exit = 1;
      }
    } else {
      rest = pairsB;
      exit = 1;
    }
    if (exit === 1) {
      return List.map((function (param) {
                    return /* tuple */[
                            param[0],
                            nullable(param[1])
                          ];
                  }), rest);
    }
    
  };
  var pairsA = List.sort((function (param, param$1) {
          return $$String.compare(param[0], param$1[0]);
        }), keyValuePairsA);
  var pairsB = List.sort((function (param, param$1) {
          return $$String.compare(param[0], param$1[0]);
        }), keyValuePairsB);
  return /* Object */Block.__(0, [aux(pairsA, pairsB)]);
}

function unify(_typeA, _typeB) {
  while(true) {
    var typeB = _typeB;
    var typeA = _typeA;
    var exit = 0;
    var exit$1 = 0;
    var exit$2 = 0;
    var exit$3 = 0;
    var exit$4 = 0;
    var exit$5 = 0;
    if (typeof typeA === "number") {
      switch (typeA) {
        case 4 : 
            if (typeof typeB === "number") {
              if (typeB === 5) {
                exit$5 = 6;
              } else {
                exit$4 = 5;
              }
            } else if (typeB.tag === 2) {
              return typeB[0];
            } else {
              exit$4 = 5;
            }
            break;
        case 5 : 
            return /* Impossible */5;
        default:
          exit$5 = 6;
      }
    } else {
      switch (typeA.tag | 0) {
        case 1 : 
            if (typeof typeB === "number") {
              switch (typeB) {
                case 4 : 
                    exit$3 = 4;
                    break;
                case 5 : 
                    exit$5 = 6;
                    break;
                default:
                  exit = 1;
              }
            } else {
              switch (typeB.tag | 0) {
                case 1 : 
                    return /* Array */Block.__(1, [unify(typeA[0], typeB[0])]);
                case 2 : 
                    exit$1 = 2;
                    break;
                default:
                  exit = 1;
              }
            }
            break;
        case 2 : 
            var x = typeA[0];
            if (typeof typeB === "number") {
              switch (typeB) {
                case 4 : 
                    return x;
                case 5 : 
                    exit$5 = 6;
                    break;
                default:
                  exit$2 = 3;
              }
            } else if (typeB.tag === 2) {
              return /* NonNull */Block.__(2, [unify(x, typeB[0])]);
            } else {
              exit$2 = 3;
            }
            break;
        default:
          exit$5 = 6;
      }
    }
    if (exit$5 === 6) {
      if (typeof typeB === "number") {
        if (typeB >= 5) {
          return /* Impossible */5;
        } else {
          exit$4 = 5;
        }
      } else {
        exit$4 = 5;
      }
    }
    if (exit$4 === 5) {
      if (typeof typeA === "number") {
        if (typeA >= 4) {
          return typeB;
        } else {
          exit$3 = 4;
        }
      } else {
        exit$3 = 4;
      }
    }
    if (exit$3 === 4) {
      if (typeof typeB === "number") {
        if (typeB >= 4) {
          return typeA;
        } else {
          exit$2 = 3;
        }
      } else {
        exit$2 = 3;
      }
    }
    if (exit$2 === 3) {
      if (typeof typeA === "number") {
        exit$1 = 2;
      } else if (typeA.tag === 2) {
        _typeA = typeA[0];
        continue ;
        
      } else {
        exit$1 = 2;
      }
    }
    if (exit$1 === 2) {
      if (typeof typeB === "number") {
        exit = 1;
      } else if (typeB.tag === 2) {
        _typeB = typeB[0];
        continue ;
        
      } else {
        exit = 1;
      }
    }
    if (exit === 1) {
      if (Caml_obj.caml_equal(typeA, typeB)) {
        return typeA;
      } else if (typeof typeA === "number") {
        switch (typeA) {
          case 1 : 
              if (typeof typeB === "number" && typeB === 2) {
                return /* Float */1;
              } else {
                return /* Impossible */5;
              }
          case 2 : 
              if (typeof typeB === "number" && typeB === 1) {
                return /* Float */1;
              } else {
                return /* Impossible */5;
              }
          default:
            return /* Impossible */5;
        }
      } else if (!typeA.tag && !(typeof typeB === "number" || typeB.tag)) {
        return unifyObjectFields(typeA[0], typeB[0]);
      } else {
        return /* Impossible */5;
      }
    }
    
  };
}

function $percent(f, g, x) {
  return Curry._1(f, Curry._1(g, x));
}

function deriveType(json) {
  if (typeof json === "number") {
    switch (json) {
      case 0 : 
      case 1 : 
          return /* NonNull */Block.__(2, [/* Bool */3]);
      case 2 : 
          return /* Any */4;
      
    }
  } else {
    switch (json.tag | 0) {
      case 0 : 
          return /* NonNull */Block.__(2, [/* String */0]);
      case 1 : 
          var num = json[0];
          return /* NonNull */Block.__(2, [Math.floor(num) === num ? /* Int */2 : /* Float */1]);
      case 2 : 
          var x = $$Array.to_list($$Array.map((function (param) {
                      return /* tuple */[
                              param[0],
                              deriveType(Js_json.classify(param[1]))
                            ];
                    }), Js_dict.entries(json[0])));
          return /* NonNull */Block.__(2, [/* Object */Block.__(0, [x])]);
      case 3 : 
          var x$1 = $$Array.fold_left(unify, /* Any */4, $$Array.map((function (param) {
                      return deriveType(Js_json.classify(param));
                    }), json[0]));
          return /* NonNull */Block.__(2, [/* Array */Block.__(1, [x$1])]);
      
    }
  }
}

function pascalCase(s) {
  return joinWith("", List.map($$String.capitalize, $$Array.to_list(s.split("_"))));
}

function camelCase(s) {
  var s$1 = $$Array.to_list(s.split("_"));
  return joinWith("", s$1 ? /* :: */[
                s$1[0],
                List.map($$String.capitalize, s$1[1])
              ] : /* [] */0);
}

function mapToGraphQLSchema(jst) {
  var typeMap = [GraphQL$ReactTemplate.TypeMap[/* empty */0]];
  var keyValMap = [Hashtbl.create(/* None */0, 10)];
  var buildObject = function (name, keyVals) {
    if (Hashtbl.mem(keyValMap[0], keyVals)) {
      return Hashtbl.find(keyValMap[0], keyVals);
    } else {
      var newObj = /* Object */Block.__(1, [/* record */[
            /* name */name,
            /* description : None */0,
            /* fields */List.map((function (param) {
                    var key = param[0];
                    var partial_arg = pascalCase(key) + "Object";
                    return /* record */[
                            /* name */camelCase(key),
                            /* description : None */0,
                            /* args : [] */0,
                            /* output_type */aux(param[1], (function (param) {
                                    return buildObject(partial_arg, param);
                                  })),
                            /* deprecated : NotDeprecated */0
                          ];
                  }), keyVals),
            /* interfaces : [] */0
          ]]);
      Hashtbl.add(keyValMap[0], keyVals, newObj);
      typeMap[0] = Curry._3(GraphQL$ReactTemplate.TypeMap[/* add */3], name, newObj, typeMap[0]);
      return newObj;
    }
  };
  var aux = function (jst, objectBuilder) {
    if (typeof jst === "number") {
      switch (jst) {
        case 1 : 
            return GraphQL$ReactTemplate.gqlFloat;
        case 2 : 
            return GraphQL$ReactTemplate.gqlInt;
        case 3 : 
            return GraphQL$ReactTemplate.gqlBoolean;
        case 0 : 
        case 4 : 
            return GraphQL$ReactTemplate.gqlString;
        case 5 : 
            return /* LazyType */Block.__(8, ["CantUnifyTypes"]);
        
      }
    } else {
      switch (jst.tag | 0) {
        case 0 : 
            return Curry._1(objectBuilder, jst[0]);
        case 1 : 
            return /* ListType */Block.__(6, [aux(jst[0], objectBuilder)]);
        case 2 : 
            return /* NonNull */Block.__(7, [aux(jst[0], objectBuilder)]);
        
      }
    }
  };
  return /* record */[
          /* query : NonNull */Block.__(7, [GraphQL$ReactTemplate.baseType(aux(jst, (function (param) {
                          return buildObject("QueryObject", param);
                        })))]),
          /* mutation : None */0,
          /* types */typeMap[0]
        ];
}

exports.nullable           = nullable;
exports.joinWith           = joinWith;
exports.unifyObjectFields  = unifyObjectFields;
exports.unify              = unify;
exports.$percent           = $percent;
exports.deriveType         = deriveType;
exports.pascalCase         = pascalCase;
exports.camelCase          = camelCase;
exports.mapToGraphQLSchema = mapToGraphQLSchema;
/* Js_dict Not a pure module */
